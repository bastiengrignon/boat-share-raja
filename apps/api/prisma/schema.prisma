generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Journey {
  id                String           @id @default(uuid())
  userId            String
  user              User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  numberOfPeople    Int              @default(0)
  maxNumberOfPeople Int              @default(0)
  from              String
  to                String
  date              DateTime
  time              String?
  price             Int?
  notes             String?
  createdAt         DateTime?        @default(now())
  updatedAt         DateTime?        @updatedAt
  JourneyRequest    JourneyRequest[]

  @@map("journey")
}

model JourneyRequest {
  id          String               @id @default(uuid())
  requesterId String
  requester   User                 @relation(fields: [requesterId], references: [id], onDelete: Cascade)
  journeyId   String
  journey     Journey              @relation(fields: [journeyId], references: [id], onDelete: Cascade)
  people      Int
  status      JourneyRequestStatus @default(PENDING)

  createdAt DateTime? @default(now())
  updatedAt DateTime  @updatedAt

  @@map("journey_request")
}

enum JourneyRequestStatus {
  PENDING
  ACCEPTED
  DECLINED
}

model User {
  id                      String                    @id @default(uuid())
  name                    String
  email                   String?
  emailVerified           Boolean                   @default(true)
  isAnonymous             Boolean?
  createdAt               DateTime?                 @default(now())
  updatedAt               DateTime?                 @updatedAt
  journeys                Journey[]
  JourneyRequest          JourneyRequest[]
  ConversationParticipant ConversationParticipant[]
  Message                 Message[]
  MessageRead             MessageRead[]
  Session                 Session[]

  @@map("user")
}

model Session {
  id        String   @id @default(uuid())
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model Island {
  id        String    @id @default(uuid())
  name      String
  createdAt DateTime? @default(now())
  updatedAt DateTime? @updatedAt

  @@map("island")
}

model Conversation {
  id        String   @id @default(uuid())
  title     String?
  isGroup   Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  participants ConversationParticipant[]
  messages     Message[]

  // Index éventuel pour filtrer les conversations récentes
  @@index([updatedAt])
  @@map("conversation")
}

model ConversationParticipant {
  id             String   @id @default(uuid())
  conversationId String
  userId         String
  joinedAt       DateTime @default(now())
  // role           String   @default("MEMBER")

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([userId])
  @@map("conversation_participant")
}

model Message {
  id             String      @id @default(uuid())
  conversationId String
  senderId       String
  content        String
  extra          Json        @default("{}")
  type           MessageType @default(TEXT)
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt
  // deletedAt      DateTime?

  conversation Conversation  @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User          @relation(fields: [senderId], references: [id], onDelete: Cascade)
  reads        MessageRead[]

  @@index([conversationId, createdAt])
  @@index([senderId])
  @@map("message")
}

model MessageRead {
  id        String   @id @default(uuid())
  messageId String
  userId    String
  readAt    DateTime @default(now())

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@index([userId])
  @@map("message_read")
}

enum MessageType {
  TEXT
  JOURNEY_REQUEST
}
